### 一、原始表达式
> JavaScript中的原始表达式包含常量或直接量、关键字和变量。
* 直接量是直接在程序中出现的常数值。
```
1.23 // 数字直接量
"hello" // 字符串直接量
/pattern/ // 正则表达式直接量
```
* JavaScript中的一些保留字构成了原始表达式
```
true // 返回一个布尔值：真
false // 返回一个布尔值：假
null // 返回一个值：空
this // 返回“当前”对象
```
* 第三种原始表达式是变量
```
i // 返回变量i的值
num // 返回sum的值
undefined // undefined是全局变量，和null不同，它不是一个关键字
```
***
### 二、对象和数组的初始化表达式
* 数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的。初始化的结果是一个新创建的数组。数组的元素是逗号分隔的表达式的值
```
[] // 一个空数组
[1+2,3+4] // 拥有两个元素的数组
[[1,2,3],[4,5,6]] // 数组初始化表达式中的元素初始化表达式也可以是数组初始化表达式
```
* 数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值undefined。
```
[1,,,,5] // 其中三个元素是undefined
```
* 数组直接量的元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值为undefined的元素
* 对象初始化表达式和数组初始化表达式非常类似，只是方括号被花括号代替，并且每个子表达式都包含一个属性名和一个冒号作为前缀。
* 对象直接量也可以嵌套
```
var p = {x: 2.3, y: -1.2};
var q = {}
q.x = 2.3;
q.y = -1.2;
var rectangle = {
    upperLeft: {x: 2, y: 2},
    lowerRight: {x: 4, y: 5}
}
var side = 1;
var rectangle = {
    'upperLeft': {x: p.x, y: p.y},
    'lowerRight': {x: p.x+side, y: p.y+side}
} // 对象直接量中的属性名称可以是字符串而不是标识符
```
***
### 三、函数定义表达式
> 一个典型的函数定义表达式包含关键字Function，跟随其后的是一对圆括号，括号内是一个以逗号分隔的列表，列表含有0个或多个标识符（参数名），然后再跟随一个由花括号包裹的JavaScript代码段。
```
var square = function(x) { return x * x; }
```
***
### 四、属性访问表达式
> 属性访问表达式运算得到一个对象属性或一个数组元素的值。JavaScript为属性访问定义了两种语法：expression.identifier和expression[expression]。
>
> 第一种写法是一个表达式后gen'su跟随一个句点和标识符。表达式指定对象，标识符则指定需要访问的属性的名称。
>
> 第二种写法是使用方括号，方括号内是另外一个表达式（这种方法适用于对象和数组）。第二个表达式指定要访问的属性的名称或者代表要访问数组元素的索引。
```
var o = {x:1,y:{z:3}};
var a = [o,4,[5,6]];
o.x // 1
x.y.z // 3
o['x'] // 1 对象o的x属性
a[1] // 4 表达式a中索引为1的元素
a[2]['1'] // 6 表达式a[2]中索引为1的元素
a[0].x // 1 表达式a[0]的x属性
```
* 不管使用哪种形式的属性访问表达式，在"."和“[”之前的表达式总是会首先计算。如果计算结果是null或者undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。如果运算结果不是对象或者数组，JavaScript会将其转换为对象。如果对象表达式后跟随句点和标识符，则会查找由这个标识符所指定的属性的值，并将其作为整个表达式的值返回。如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它装换为字符串。不论哪种情况，如果命名的属性不存在，那么整个属性访问表达式的值就是undefined。
* .identifier的写法需要注意的是，这种方式只适用于要访问的属性名称是合法的标识符，并且需要知道要访问的属性的名字。==如果属性名称是一个保留字或包含空格和标点符号，或是一个数字，则必须适用方括号的写法。当属性名是通过运算得出的值而不是固定的值的时候，这时必须使用方括号写法。==
***
### 五、调用表达式
> JavaScript中的调用表达式是一种调用（或者执行）函数或方法的语法表示。它以一个函数表达式开始，这个函数表达式指代了要调用的函数。函数表达式后跟随一对圆括号，括号内是一个以逗号隔开的参数列表，参数可以有0个也可以有多个。
* 当对调用表达式进行求值时，首先计算函数表达式，然后计算参数表达式，得到一组参数值。如果函数表达式的值不是一个可调用的对象，则抛出一个类型错误异常。然后，实参的值被依次赋值给形参，这些形参是定义函数时指定的，接下来开始执行函数体。
* 如果函数使用return语句给出一个返回值，那么这个返回值就是整个调用表达式的值。否则，调用表达式的值就是undefined。
***
### 六、对象创建表达式
> 对象创建表达式创建一个对象并调用一个函数（这个函数称做构造函数）初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象表达式之前多了一个关键字new
```
new Object()
new Point(2,3)
```
> 如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略的
```
new Object
new Date
```
***
### 七、运算符概述
> JavaScript中的运算符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。
* 左值：是指表达式只能出现在赋值运算符的左侧。
* 通常用void 0来获取靠谱的undefined。判断未声明变量只能用typeof obj === 'undefined'不能用obj === void 0代替，因为如果试图引用一个未声明变量的值，虚拟机会抛ReferenceError异常。
* 逗号运算符：忽略第一个操作数，返回第二个操作数。
```
var a = (1,2,3,4,5) // => 5
```

#### 操作数的个数
分为一元、二元、三元表达式，JavaScript中的大部分运算符都是二元运算符，表达式-x中的-就是一元表达式，条件判断运算符“?:”是一个三元表达式。

#### 运算符的副作用
> 如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会发生改变。++和--递增和递减运算符与此类似，因为它们包含了隐式的赋值。

#### 运算符优先级
> 需要注意：属性访问表达式和调用表达式的优先级要比所有的运算符都要高
```
typeof my.function[x](y)
```
尽管typeof是优先级最高的运算符之一，但它也是在两次属性访问和函数调用之后执行的

#### 运算符的结合性
> 结合性指定了在多个具有同样优先级的运算符表达式中的运算顺序。
```
x = ~-y // 等价于 x = ~(-y)
w = x = y = z // 等价于 w = (x = (y = z))
q = a?b:c?d:e?f:g // 等价于 q = a?b:(c?d:(e?f:g))
```
#### 运算顺序
假设存在a=1，那么b=(a++)+a将如何计算？顺序是这样的：  
1.计算b;  
2.计算a++(假设值为c)  
3.计算a  
4.将c+a的结果赋值给b  
按照++的定义第2步中计算结果仍为1，随后a立即增1，所以最后b为3

***
### 八、算术表达式
> JavaScript中所有数字都是浮点型，除法运算的结果也为浮点型，比如5/2的结果是2.5，而不是2。除数为0的运算结果为正无穷大或负无穷大，而0/0的结果是NaN，所有这些运算都不会报错。

#### “+”运算符
> 加号的转换规则优先考虑字符串连接，如果其中一个操作数是字符串或者转换为字符串的对象，另一个操作数将会转换为字符串，加法将进行字符串的连接操作。如果两个操作符都不是类字符串的，那么都将进行算术加法运算。
* 如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类值：日期对象通过toString()方法执行转换，其他对象则通过valueOf()方法执行转换（如果valueOf()方法返回一个原始值的话）。由于多数对象都不具备可用的valueOf()方法，因此它们会通过toString()方法来执行转换。
* 在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串连接。
* 否则，两个操作数都将转换为数字（或者NaN），然后进行加法操作。

```
"1" + "2" // => "12"
"1" + 2 // => "12"
1 + {} // => "1[object Object]" 对象转换为字符串进行连接
true + true // => 2 布尔值转换为数字后做加法
2 + null // => 2 null转换为0后做加法
2 + undefined // => NaN undefined转换为NaN后做加法
```
* ==最后需要注意的是，当加号运算符和字符串和数字一起使用时，需要考虑加法的结合性对运算顺序的影响==
```
1 + 2 + ' blind' // => "3 blind"
1 + (2 + ' blind') // => "12 blind"
```

#### 一元运算符
##### 1. 一元加法（+）
一元加法运算符把操作数转换为数字（或者NaN），并返回这个转换后的数字。如果操作数本身就是数字，则直接返回这个数字。
##### 2. 一元减法（-）
当“-”用做一元运算符时，它会根据需要把操作数转换为数字，然后改变运算结果的符号。
##### 3. 递增（++）
递增运算符的返回值依赖于它相对于操作数的位置。不能在后增量运算符和操作数之间插入换行符，不然JavaScript会把操作数当做一条单独的语句，并在其之前补上一个分号。
##### 4. 递减（--）
同递增

#### 位运算符
> 位运算符可以对由数字表示的二进制数据进行更低层级的按位运算。
>
> 位运算符要求它的操作数是整数，这些整数表示为32位整型而不是64位浮点型。必要时，位运算符首先将操作数转换为数字，并将数字强制表示为32位整型，这会忽略原格式中的小数部分和任何超过32位的二进制位。
>
> 位运算符会将NaN，Infinity和-Infinity都转换为0。

***
### 九、关系表达式
#### 相等和不等运算符
严格相等运算符“===”首先计算其操作数的值，然后比较这两个值，比较过程没有任何类型转换：
* 如果两个值类型不相同，则它们不相等。
* 如果两个值都是null或者都是undefined，则它们不相等。
* 如果两个值都是布尔值true或都是布尔值false，则它们相等。
* 如果其中一个值是NaN，或者两个值都是NaN，则它们不相等。NaN和其他任何值都是不相等的，包括它本身。通过x!==x来判断x是否为NaN，只有在x为NaN的时候，这个表达式的值才为true。
* 如果两个值为数字且数值相等，则它们相等。如果一个值为0，另一个值为-0，则它们同样相等。
* 如果两个值为字符串，且所含的对应位上的16位数完全相等，则它们相等。如果它们的长度或内容不同，则它们不等。两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的16位值。JavaScript并不对Unicode进行标准化的转换，因此像这样的字符串通过“ === ”和“ == ”运算符的比较结果也不相等。
* 如果两个引用值指向同一个对象、数组或函数，则它们是相等的。如果指向不同的对象，则它们是不等的，尽管两个对象具有完全一样的属性。

相等运算符“ == ”和恒等运算符相似，但相等运算符的比较并不严格。如果两个操作数不是同一类型，那么相等运算符会尝试进行一些类型转换，然后比较：
* 如果两个操作数的类型相同，则和上文所述的严格相等的比较规则一样。如果严格相等，那么比较结果为相等。如果它们不严格相等，则比较结果为不相等。
* 如果两个操作数类型不同，“ == ”相等操作符也可能会认为它们相等。检测相等将会遵守如下规则和类型转换：
  1.  如果一个值是null，另一个是undefined，则它们相等。
  2.  如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。
  3.  ==如果其中一个值是true，则将其转换为1再进行比较。== 如果其中一个值是false，则将其转换为0再进行比较。
  4.  如果一个值是对象，另一个值是数字或字符串，则使用转换规则将对象转换为原始值，然后再进行比较。对象通过toString()方法或者valueOf()方法转换为原始值。JavaScript语言核心的内置类首先尝试使用valueOf()，再尝试使用toString()，除了日期类，日期类只使用toString()转换。那些不是JavaScript语言核心中的对象则通过各自的实现中定义的方法转换为原始值。
  5.  其他不同类型之间的比较均不相等。
  ```
  "1" == true // => true
  "asd" == true // => false
  ```
  #### 比较运算符
  > 比较运算符的操作数可能是任意类型。然而，只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换，转换规则如下：

* 如果操作数是对象，那么这个对象将按照类型转换规则进行转换：如果valueOf返回一个原始值，那么直接使用这个原始值。否则，使用toString的转换结果进行比较操作。
* 在对象转换为原始值之后
